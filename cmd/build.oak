// oak build -- compiler and bundler

{
	println: println
	default: default
	slice: slice
	clone: clone
	map: map
	each: each
	filter: filter
	append: append
	entries: entries
	merge: merge
	once: once
} := import('std')
{
	join: join
	split: split
	replace: replace
} := import('str')
{
	sort!: sort!
} := import('sort')
{
	readFile: readFile
	writeFile: writeFile
	statFile: statFile
} := import('fs')
{
	printf: printf
	format: format
} := import('fmt')
{
	dir: dir
	resolve: resolve
} := import('path')
cli := import('cli')
syntax := import('syntax')

Cli := cli.parse()

Entry := Cli.opts.entry
Web? := Cli.opts.web != ?
Output := Cli.opts.output |> default(Cli.opts.o)
Includes := Cli.opts.include |> default('') |>
	split(',') |>
	filter(fn(s) s != '') |>
	with map() fn(spec) if [name, path] := spec |> split(':') {
	[_, _] -> { name: name, path: resolve(path) + '.oak' }
	_ -> { name: spec, path: resolve(spec) + '.oak' }
}

if Entry {
	?, '', true -> {
		printf('[oak build] No --entry specified.')
		exit(1)
	}
}
if Output {
	?, '', true -> {
		printf('[oak build] No --output specified.')
		exit(1)
	}
}
if statFile(Entry) {
	? -> {
		printf('[oak build] {{0}} does not exist.', Entry)
		exit(1)
	}
}

// absolute path to the entrypoint module
AbsoluteEntry := resolve(Entry)

// a { string: [Node] } that maps absolute paths of imported modules to their
// fully parsed AST. We cache it here because we need to potentially astgen
// modules multiple times in the compilation process. This also serves as the
// source of truth for which modules the bundle must include.
ModuleNodes := {}

// cachedParse is a wrapper around syntax.parse that lazily caches the computed
// AST, so we can minimize redundant work.
// The path must be absolute, but the text is optional if the path is
// guaranteed to be cached.
fn cachedParse(path, text) if cached := ModuleNodes.(path) {
	? -> {
		printf('[oak build] Parsing {{0}}...', path)
		ModuleNodes.(path) := text |> syntax.parse()
		ModuleNodes.(path)
	}
	_ -> cached
}

// importCallNode? reports whether a given AST node represents an expression of
// the form _ := import(_), which signals that it's an import that the compiler
// must handle specially.
fn importCallNode?(node) node = {
	type: :assignment
	tok: _
	local?: true
	left: _
	right: {
		type: :fnCall
		function: { type: :identifier, val: 'import', tok: _ }
		args: [{ type: :string, val: _, tok: _ }]
		restArg: ?
		tok: _
	}
}

// number of modules we started processing
startedImport := 0
// number of modules done processing
finishedImport := 0
// addImportsFromFile reads and parses a file at a given path, and potentially
// dispatches further addImportsFromFile calls to modules imported by the given
// module. Calling this on an entrypoint module will eventually reach all of
// the modules it imports recursively.
//
// Takes a callback, next, that runs when the dependency tree is fully covered.
fn addImportsFromFile(path, next) {
	startedImport <- startedImport + 1

	with readFile(path) fn(file) if file {
		? -> printf('[oak build] Import {{0}} does not exist.', path)
		_ -> {
			addImportsFromSource(path, file, next)

			// if there are no more queued jobs, invoke callback
			if finishedImport <- finishedImport + 1 {
				startedImport -> next()
			}
		}
	}
}
// addImportsFromSource takes an Oak source file and recursively imports
// modules included from that entrypoint. It is dual to addImportsFromFile, but
// takes a source file rather than a path to a file on disk.
//
// Takes a callback, next, that runs when the dependency tree is fully covered.
fn addImportsFromSource(path, file, next) {
	// find static, top-level imports from this file and queue jobs to analyze
	// their imports.
	cachedParse(path, file) |> with each() fn(node) if {
		importCallNode?(node) -> if ___runtime_lib?(importName := node.right.args.(0).val) {
			// for Oak bundles, importing stdlib is a no-op
			true -> if Web? {
				// for JS bundles, bundle the stdlib
				true -> addImportsFromSource(importName, ___runtime_lib(importName), next)
			}
			_ -> {
				importPath := resolve(importName, dir(path)) + '.oak'
				// TODO: move this to analysis phase, so we don't depend on
				// mutating cached AST in-place
				node.right.args.(0).val := importPath
				// kick off job if we haven't seen this module before
				if ModuleNodes.(importPath) {
					? -> addImportsFromFile(importPath, next)
				}
			}
		}
	}
}

// wrapBlock returns a block AST node containing all the given nodes as
// sub-expressions of the block. In effect, it makes N AST nodes 1 node.
fn wrapBlock(nodes) {
	type: :block
	tok: { pos: [1, 1], type: :leftBrace, val: ? }
	exprs: nodes
}

// When translating between incompatible identifier names or symbols, Oak
// names will be appended to "__oak_js_" to produce a valid JS name, e.g.
// Oak identifier "const" (a JS reserve word) becomes "__oak_js_const".
if Web? {
	false -> fn formatIdent(name) name |> clone()
	_ -> fn formatIdent(name, key) if name {
		// prevent shadowing of some meaningful global '_' variable
		'_' -> '_oak_empty_ident' << string(key |> default(''))
		// ECMAScript 2021 reserved words, cannot be used as identifiers
		'await', 'break', 'case', 'catch', 'class', 'const', 'continue'
		'debugger', 'default', 'delete', 'do', 'else', 'enum', 'export'
		'extends', 'false', 'finally', 'for', 'function', 'if', 'import', 'in'
		'instanceof', 'let', 'new', 'null', 'return', 'super', 'switch'
		'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while'
		'with', 'yield' -> '__oak_js_' << name
		_ -> name |>
			clone() |>
			replace('?', '__oak_qm') |>
			replace('!', '__oak_exclam')
	}
}

// wrapModule takes the body of a module and wraps it in a closure that returns
// a global `module` object. It returns a single AST node object representing
// this closure, to be wrapped further into a bundle AST.
fn wrapModule(block) {
	// wrap nodes in AST of
	// fn {
	//     module := {}
	//     { ... (module code) }
	//     module
	// }
	type: :function
	name: ''
	tok: { pos: [1, 1], type: :fnKeyword, val: ? }
	args: []
	restArg: ''
	body: {
		type: :block
		tok: { pos: [1, 4], type: :leftBrace, val: ? }
		decls: block.decls << 'module'
		exprs: [{
			left: { tok: { pos: [1, 6], type: :identifier, val: 'module' }, type: :identifier, val: 'module' }
			local?: true
			right: { entries: [], tok: { pos: [1, 16], type: :leftBrace, val: ? }, type: :object }
			tok: { pos: [1, 13], type: :assign, val: ? }
			type: :assignment
		}] |> append(block.exprs) |> append(map(block.decls, fn(exportedName) {
			type: :assignment
			tok: { pos: [1, 10], type: :assign, val: ? }
			local?: true
			left: {
				type: :propertyAccess
				tok: { pos: [1, 7], type: :dot, val: ? }
				left: {
					type: :identifier
					tok: { pos: [1, 1], type: :identifier, val: 'module' }
					val: 'module'
				}
				right: {
					type: :identifier
					tok: { pos: [1, 8], type: :identifier, val: formatIdent(exportedName) }
					val: formatIdent(exportedName)
				}
			}
			right: {
				type: :identifier
				tok: { pos: [1, 13], type: :identifier, val: formatIdent(exportedName) }
				val: formatIdent(exportedName)
			}
		}) << {
			tok: { pos: [1, 20], type: :identifier, val: 'module' }
			type: :identifier
			val: 'module'
		})
	}
}

// wrapBundle takes a list of module AST nodes (closures) and wraps it into a
// single bundle AST node with an entrypoint. The bundle AST then gets
// serialized into Oak or JS code to be written to disk.
//
// The bundle contains an object of type { (name: string): Module }, where the
// Module is a closure called exactly once at runtime (on import) to return a
// `module` exports object which takes the place of the closure that produced
// it, for later imports of the same module to consume. The runtime also
// includes a small bit of code to invoke the entrypoint module closure, as
// well a shim that redefines `import()` in the bundle to check the bundle
// object instead of executing Oak's default import() builtin.
fn wrapBundle(modules, entryModuleName) {
	type: :block
	tok: { pos: [1, 1], type: :leftBrace, val: ? }
	decls: []
	exprs: {
		// declare all modules with __oak_modularize
		moduleDefns := modules |> with map() fn(module) {
			[moduleName, moduleBody] := module
			{
				type: :fnCall
				tok: { pos: [1, 17], type: :leftParen, val: ? }
				function: {
					type: :identifier
					tok: { pos: [1, 1], type: :identifier, val: '__oak_modularize' }
					val: '__oak_modularize'
				}
				args: [
					{ type: :string, val: moduleName, tok: { type: :stringLiteral, pos: [1, 18], val: moduleName } }
					moduleBody
				]
				restArg: ?
			}
		}

		// call into entrypoint
		moduleDefns << {
			type: :assignment
			tok: { pos: [1, 0], type: :assign, val: ? }
			left: { tok: { pos: [1, 0], type: :identifier, val: '__Oak_Import_Aliases' }, type: :identifier, val: '__Oak_Import_Aliases' }
			local?: true
			right: {
				type: :object
				tok: { pos: [1, 0], type: :leftBrace, val: ? }
				entries: Includes |> with map() fn(spec) {
					key: { type: :string, val: spec.name, tok: { pos: [1, 0], type: :stringLiteral, val: spec.name } }
					val: { type: :string, val: spec.path, tok: { pos: [1, 0], type: :stringLiteral, val: spec.path } }
				}
			}
		} << {
			type: :fnCall
			tok: { pos: [1, 0], type: :leftParen, val: ? }
			function: {
				type: :identifier
				tok: { pos: [1, 0], type: :identifier, val: '__oak_js_import' }
				val: '__oak_js_import'
			}
			args: [{
				type: :string
				val: entryModuleName
				tok: { type: :stringLiteral, pos: [1, 0], val: entryModuleName }
			}]
			restArg: ?
		}
	}
}

// analyzeNode performs static semantic analysis on an AST node, descending
// recursively down the syntax tree. It does not mutate the original tree, but
// rather returns a transformed, completely new syntax tree containing
// transformations and annotations necessary for codegen.
fn analyzeNode(node) {
	fn analyzeSubexpr(node, ctx, tail?) {
		if node.type {
			:block -> {
				ctx := clone(ctx)

				ctx.decls := {}
				node.exprs := node.exprs |> map(fn(n, i) analyzeSubexpr(n, ctx, i + 1 = len(node.exprs)))

				// do not re-declare function parameters
				node.decls := ctx.decls |> keys() |> with filter() fn(decl) ctx.args.(decl) = ?
				node
			}
			:function -> {
				// we ought only count as "recursion" when a function directly
				// calls itself -- we do not count references to itself in
				// other callbacks, which may be called asynchronously
				if ctx.enclosingFnLit {
					node -> ?
					_ -> ctx.enclosingFnLit := _
				}

				fnCtx := clone(ctx)

				if node.name {
					? -> ?
					_ -> fnCtx.enclosingFn := node
				}

				fnCtx.decls := {}
				fnCtx.args := {}
				node.args |> with each() fn(arg) fnCtx.args.(arg) := true
				node.body := analyzeSubexpr(node.body, fnCtx, true)

				// do not re-declare function parameters
				node.decls := fnCtx.decls |> keys() |> with filter() fn(decl) fnCtx.args.(decl) = ?

				trampolinedFnName := '__oak_trampolined_' << fnCtx.enclosingFn.name
				if fnCtx.enclosingFn.recurred? {
					true -> node <- {
						type: :function
						name: node.name
						tok: node.tok
						args: node.args |> clone()
						restArg: node.restArg
						decls: []
						body: {
							type: :block
							tok: node.tok
							decls: [trampolinedFnName]
							exprs: [{
								type: :assignment
								tok: node.tok
								local?: true
								left: {
									type: :identifier
									tok: node.tok
									val: trampolinedFnName
								}
								right: merge({}, node, { name: '' })
							}, {
								type: :fnCall
								tok: node.tok
								function: {
									type: :identifier
									tok: node.tok
									val: '__oak_resolve_trampoline'
								}
								args: [{
									type: :identifier
									tok: node.tok
									val: trampolinedFnName
								}] |> append(node.args |> with map() fn(arg) {
									type: :identifier
									tok: node.tok
									val: arg
								})
								restArg: if node.restArg {
									'' -> ?
									_ -> {
										type: :identifier
										tok: node.tok
										val: node.restArg
									}
								}
							}]
						}
					}
				}

				// a function with a name also assigns
				if node.name {
					'' -> ?
					_ -> ctx.decls.(node.name) := true
				}

				node
			}
			:ifExpr -> {
				node.cond := analyzeSubexpr(node.cond, ctx, false)
				node.branches := node.branches |> with map() fn(br) analyzeSubexpr(br, ctx, true)
				node
			}
			:ifBranch -> {
				node.target := analyzeSubexpr(node.target, ctx, false)
				node.body := analyzeSubexpr(node.body, ctx, true)
				node
			}
			:fnCall -> {
				node.function := analyzeSubexpr(node.function, ctx, false)
				node.args := node.args |> with map() fn(a) analyzeSubexpr(a, ctx, false)
				if node.restArg {
					? -> ?
					_ -> node.restArg := analyzeSubexpr(node.restArg, ctx, false)
				}

				simpleName? := node.function.type = :identifier
				recursiveCall? := if ctx.enclosingFn {
					? -> false
					_ -> node.function.val = ctx.enclosingFn.name
				}

				if simpleName? & recursiveCall? & tail? {
					true -> {
						ctx.enclosingFn.recurred? := true
						{
							type: :fnCall
							tok: node.tok
							function: {
								type: :identifier
								tok: node.tok
								val: '__oak_trampoline'
							}
							args: [{
								type: :identifier
								tok: node.tok
								val: '__oak_trampolined_' << node.function.val
							}] |> append(node.args)
							restArg: node.restArg
						}
					}
					_ -> node
				}
			}
			:unary -> node.right := analyzeSubexpr(node.right, ctx, false)
			:binary, :propertyAccess -> {
				node.left := analyzeSubexpr(node.left, ctx, false)
				node.right := analyzeSubexpr(node.right, ctx, false)
				node
			}
			:assignment -> {
				node.left := analyzeSubexpr(node.left, ctx, false)
				node.right := analyzeSubexpr(node.right, ctx, false)

				if node.local? {
					true -> if node.left.type {
						:identifier -> ctx.decls.(node.left.val) := true
						:list -> node.left.elems |> with each() fn(el) if el.type {
							:identifier -> ctx.decls.(el.val) := true
						}
						:object -> node.left.entries |> with each() fn(entry) if entry.key.type {
							:identifier -> ctx.decls.(entry.key.val) := true
						}
					}
				}

				node
			}
			:list -> node.elems := node.elems |> with map() fn(el) analyzeSubexpr(el, ctx, false)
			:object -> node.entries := node.entries |> with map() fn(entry) {
				key: analyzeSubexpr(entry.key, ctx, false)
				val: analyzeSubexpr(entry.val, ctx, false)
			}
			_ -> node
		}
	}
	analyzeSubexpr(node, {
		decls: {}
		args: {}
	}, false)
}

// renderOakNodes renders Oak AST nodes to Oak program text
fn renderOakBundle(bundleNode) {
	// TODO: render

	fn renderNode(node) if node.type {
		_ -> string(node)
	}

	'/* oak build */' << renderNode(bundleNode)
}

// renderJSNodes renders Oak AST nodes to JavaScript program text.
// renderJSNodes is also responsible for adding the JavaScript Oak runtime,
// which provides language compatibility features.
fn renderJSBundle(bundleNode) {
	fn renderErr(msg) 'throw new Error(\'' << replace(msg, '\'', '\\\'') << '\')'

	fn renderAssignTarget(node) if node.type {
		// not a bare '_' to avoid common conflicts with global '_' name
		:empty -> '__oak_empty_assgn_trgt'
		:identifier -> formatIdent(node.val)
		:propertyAccess -> if node.right.type {
			:identifier -> '({{0}}.{{1}})' |> format(renderNode(node.left), renderNode(node.right))
			_ -> '({{0}}[{{1}}])' |> format(renderNode(node.left), renderNode(node.right))
		}
		:list -> '[' << (node.elems |> map(renderAssignTarget) |> join(',')) << ']'
		:object -> '{' << {
			node.entries |> map(fn(entry) {
				{ key: k, val: v } := entry
				if k.type {
					:identifier, :empty, :number -> renderNode(k)
					_ -> '[' << renderNode(k) << ']'
				} << ':' << renderAssignTarget(v)
			}) |> join(',')
		} << '}'
	}

	fn renderNode(node) {
		if node.type {
			:null -> 'null'
			:empty -> '__Oak_Empty'
			:string -> '__Oak_String(`' + replace(replace(node.val, '\\', '\\\\'), '`', '\\`') + '`)'
			:number, :boolean -> string(node.val)
			:identifier -> formatIdent(node.val)
			:atom -> 'Symbol.for(\'' << string(node.val) << '\')'
			:list -> '[' << (node.elems |> map(renderNode) |> join(',')) << ']'
			:object -> '{' << {
				node.entries |> map(fn(entry) {
					{ key: k, val: v } := entry
					if k.type {
						:identifier, :empty, :number -> renderNode(k)
						_ -> '[' << renderNode(k) << ']'
					} << ':' << renderNode(v)
				}) |> join(',')
			} << '}'
			:unary -> if node.op {
				:minus -> '-' << renderNode(node.right)
				:exclam -> '!' << renderNode(node.right)
				_ -> renderErr('Not implemented: unary op ' << string(node.type))
			}
			:binary -> if node.op {
				:plus -> '__as_oak_string({{0}}+{{1}})' |> format(renderNode(node.left), renderNode(node.right))
				:minus -> '({{0}}-{{1}})' |> format(renderNode(node.left), renderNode(node.right))
				:times -> '({{0}}*{{1}})' |> format(renderNode(node.left), renderNode(node.right))
				:divide -> '({{0}}/{{1}})' |> format(renderNode(node.left), renderNode(node.right))
				:modulus -> '({{0}}%{{1}})' |> format(renderNode(node.left), renderNode(node.right))

				:and -> '__oak_and({{0}},{{1}})' |> format(renderNode(node.left), renderNode(node.right))
				:xor -> '__oak_xor({{0}},{{1}})' |> format(renderNode(node.left), renderNode(node.right))
				:or -> '__oak_or({{0}},{{1}})' |> format(renderNode(node.left), renderNode(node.right))

				:eq -> '__oak_eq({{0}},{{1}})' |> format(renderNode(node.left), renderNode(node.right))
				:neq -> '!__oak_eq({{0}},{{1}})' |> format(renderNode(node.left), renderNode(node.right))

				:greater -> '({{0}}>{{1}})' |> format(renderNode(node.left), renderNode(node.right))
				:less -> '({{0}}<{{1}})' |> format(renderNode(node.left), renderNode(node.right))
				:geq -> '({{0}}>={{1}})' |> format(renderNode(node.left), renderNode(node.right))
				:leq -> '({{0}}<={{1}})' |> format(renderNode(node.left), renderNode(node.right))

				:pushArrow -> '__oak_push({{0}},{{1}})' |> format(renderNode(node.left), renderNode(node.right))
			}
			:assignment -> if node.left.type {
				:propertyAccess -> if node.right.type {
					:empty -> 'delete ' << renderAssignTarget(node.left)
					_ -> {
						tmpDfn := clone(node.left)
						tmpDfn.left := {
							type: :identifier
							tok: node.tok
							val: '__oak_assgn_trgt'
						}

						// this production preserves two Oak semantics:
						// - strings can be mutably assigned to.
						// - assignment on strings and composites return the assignment
						//   target, not the assigned value, as the value of the
						//   expression
						[
							'(()=>{let __oak_assgn_trgt=__as_oak_string({{0}})'
							'__is_oak_string(__oak_assgn_trgt)?__oak_assgn_trgt.assign({{3}},{{2}}):({{1}}={{2}})'
							'return __oak_assgn_trgt})()'
						] |> join(';') |> format(
							renderNode(node.left.left)
							// composite assignment
							renderAssignTarget(tmpDfn)
							renderNode(node.right)
							// string assignment
							renderNode(node.left.right)
						)
					}
				}
				_ -> '(' << renderAssignTarget(node.left) << '=' << renderNode(node.right) << ')'
			}
			:propertyAccess -> if node.right.type {
				:identifier -> [
					'(()=>{let __oak_acc_trgt=__as_oak_string({{0}})'
					'return __is_oak_string(__oak_acc_trgt)?__oak_acc_trgt.valueOf()[{{1}}]||null:(__oak_acc_trgt.{{1}}!==undefined?__oak_acc_trgt.{{1}}:null)})()'
				] |> join(';') |> format(renderNode(node.left), renderNode(node.right))
				_ -> [
					'(()=>{let __oak_acc_trgt=__as_oak_string({{0}})'
					'return __is_oak_string(__oak_acc_trgt)?__oak_acc_trgt.valueOf()[{{1}}]||null:(__oak_acc_trgt[{{1}}]!==undefined?__oak_acc_trgt[{{1}}]:null)})()'
				] |> join(';') |> format(renderNode(node.left), renderNode(node.right))
			}
			:ifExpr -> '__oak_if(' << renderNode(node.cond) << ',[' << {
				node.branches |> map(fn(br) {
					'[()=>({{0}}),()=>({{1}})]' |> format(renderNode(br.target), renderNode(br.body))
				}) |> join(',')
			} << '])'
			:block -> if len(node.exprs) {
				0 -> 'null'
				_ -> if len(node.decls) {
					0 -> '(' << (node.exprs |> map(renderNode) |> join(',')) << ')'
					_ -> '(()=>{ {{0}}{{1}} })()' |> format(
						node.decls |> sort!() |> map(fn(decl) 'let ' << formatIdent(decl) << ';') |> join()
						{
							exprs := node.exprs |> map(renderNode)
							exprs.(len(exprs) - 1) := 'return ' << exprs.(len(exprs) - 1)
							exprs |> join(';')
						}
					)
				}
			}
			:function -> {
				args := '(' << if node.restArg {
					'' -> node.args |> map(fn(a, i) formatIdent(a, i) << '=null') |> join(',')
					_ -> node.args |> map(fn(a, i) formatIdent(a, i) << '=null') |>
						append(['...' << formatIdent(node.restArg)]) |> join(',')
				} << ')'
				if node.name {
					'' -> 'function' << args << '{return ' << renderNode(node.body) << '}'
					// use function keyword for named functions, for legible stack traces
					_ -> formatIdent(node.name) <<
						'=function ' <<
						formatIdent(node.name) <<
						args << '{return ' << renderNode(node.body) << '}'
				}
			}
			:fnCall -> '{{0}}({{1}})' |> format(
				if node.function.type {
					:function -> '(' << renderNode(node.function) << ')'
					_ -> renderNode(node.function)
				}
				if node.restArg {
					? -> node.args |> map(renderNode) |> join(',')
					_ -> node.args |> map(renderNode) |> append(['...' << renderNode(node.restArg)]) |> join(',')
				}
			)
			_ -> renderErr('Not implemented: node ' << string(node.type))
		}
	}

	'/* oak build --web */' << OakJSRuntime << renderNode(bundleNode)
}

// renderBundle transforms a bundle's AST nodes to compiled program text
fn renderBundle(bundleNode) if {
	Web? -> renderJSBundle(bundleNode)
	_ -> renderOakBundle(bundleNode)
}

// Start from entrypoint and explicit includes, collect all static imports
printf('[oak build] Bundling with entrypoint {{0}}', Entry)
postImport := with once() fn {
	// compile the import map into a bundle with an entrypoint and render to
	// bundle program text
	BundleFile := ModuleNodes |>
		keys() |>
		sort!() |>
		map(fn(name) [name, name |> cachedParse() |> wrapBlock() |> analyzeNode() |> wrapModule()]) |>
		wrapBundle(AbsoluteEntry) |>
		renderBundle()

	with writeFile(Output, BundleFile) fn(res) if res {
		? -> printf('[oak build] Could not write bundle to {{0}}.', Output)
		_ -> printf('[oak build] Bundle written to {{0}}', Output)
	}
}
Includes |> with each() fn(spec) if ___runtime_lib?(spec.name) {
	true -> if Web? {
		true -> addImportsFromSource(spec.name, ___runtime_lib(spec.name))
	}
	_ -> if ModuleNodes.(spec.path) {
		? -> addImportsFromFile(spec.path, postImport)
	}
}
addImportsFromFile(AbsoluteEntry, postImport)


// constants and runtime
OakJSRuntime := '
// module system
const __Oak_Modules = {};
function __oak_js_import(name) {
	if (typeof __Oak_Modules[name] === \'object\') return __Oak_Modules[name];
	const module = __Oak_Modules[name] || __Oak_Modules[__Oak_Import_Aliases[name]];
	if (module) {
		return __Oak_Modules[name] = module();
	} else {
		throw new Error(`Could not import Oak module "${name}" at runtime`);
	}
}
function __oak_modularize(name, fn) {
	__Oak_Modules[name] = fn;
}

// language primitives
let __oak_empty_assgn_trgt;
function __oak_eq(a, b) {
	a = __as_oak_string(a);
	b = __as_oak_string(b);
	if (a === __Oak_Empty || b === __Oak_Empty) return true;

	// match either null or undefined to compare correctly against undefined ?s
	// appearing in places like optional arguments
	if (a == null && b == null) return true;
	if (a === null || b === null) return false;

	if (typeof a !== typeof b) return false;
	if (__is_oak_string(a) && __is_oak_string(b)) {
		return a.valueOf() === b.valueOf();
	}
	if (typeof a === \'number\' || typeof a === \'boolean\' ||
		typeof a === \'function\' || typeof a === \'symbol\') {
		return a === b;
	}

	// deep equality check for composite values
	if (!Array.isArray(a) && typeof a !== \'object\') return false;
	if (len(a) !== len(b)) return false;
	for (const key of keys(a)) {
		if (!__oak_eq(a[key], b[key])) return false;
	}
	return true;
}
function __oak_push(a, b) {
	a = __as_oak_string(a);
	a.push(b);
	return a;
}
function __oak_and(a, b) {
	if (typeof a === \'boolean\' && typeof b === \'boolean\') {
		return a && b;
	}
	if (__is_oak_string(a) && __is_oak_string(b)) {
		const max = Math.max(a.length, b.length);
		const get = (s, i) => s.valueOf().charCodeAt(i) || 0;

		let res = \'\';
		for (let i = 0; i < max; i ++) {
			res += String.fromCharCode(get(a, i) & get(b, i));
		}
		return res;
	}
	return a & b;
}
function __oak_or(a, b) {
	if (typeof a === \'boolean\' && typeof b === \'boolean\') {
		return a || b;
	}
	if (__is_oak_string(a) && __is_oak_string(b)) {
		const max = Math.max(a.length, b.length);
		const get = (s, i) => s.valueOf().charCodeAt(i) || 0;

		let res = \'\';
		for (let i = 0; i < max; i ++) {
			res += String.fromCharCode(get(a, i) | get(b, i));
		}
		return res;
	}
	return a | b;
}
function __oak_xor(a, b) {
	if (typeof a === \'boolean\' && typeof b === \'boolean\') {
		return (a && !b) || (!a && b);
	}
	if (__is_oak_string(a) && __is_oak_string(b)) {
		const max = Math.max(a.length, b.length);
		const get = (s, i) => s.valueOf().charCodeAt(i) || 0;

		let res = \'\';
		for (let i = 0; i < max; i ++) {
			res += String.fromCharCode(get(a, i) ^ get(b, i));
		}
		return res;
	}
	return a ^ b;
}
function __oak_if(cond, branches) {
	for (const [target, body] of branches) {
		if (__oak_eq(cond, target())) return body();
	}
	return null;
}
const __Oak_Empty = Symbol(\'__Oak_Empty\');

// mutable string type
function __is_oak_string(x) {
	if (x == null) return false;
	return x.__mark_oak_string;
}
function __as_oak_string(x) {
	if (typeof x === \'string\') return __Oak_String(x);
	return x;
}
const __Oak_String = s => {
	if (__is_oak_string(s)) return s;
	return {
		__mark_oak_string: true,
		assign(i, slice) {
			if (i === s.length) return s += slice;
			return s = s.substr(0, i) + slice + s.substr(i + slice.length);
		},
		push(slice) {
			s += slice;
		},
		toString() {
			return s;
		},
		valueOf() {
			return s;
		},
		get length() {
			return s.length;
		},
	}
}

// tail recursion trampoline helpers
function __oak_resolve_trampoline(fn, ...args) {
	let rv = fn(...args);
	while (rv && rv.__is_oak_trampoline) {
		rv = rv.fn(...rv.args);
	}
	return rv;
}
function __oak_trampoline(fn, ...args) {
	return {
		__is_oak_trampoline: true,
		fn: fn,
		args: args,
	}
}

// env (builtin) functions

// reflection and types
const __Is_Oak_Node = typeof process === \'object\';
function int(x) {
	if (typeof x === \'number\') {
		// JS rounds towards higher magnitude, Oak rounds towards higher value
		const rounded = Math.floor(x);
		const diff = x - rounded;
		if (x < 0 && diff === 0.5) return rounded + 1;
		return rounded;
	}
	if (__is_oak_string(x)) {
		const i = parseInt(x.valueOf());
		if (isNaN(i)) return null;
		return i;
	}
	return null;
}
function float(x) {
	if (typeof x === \'number\') return x;
	if (__is_oak_string(x)) {
		const f = parseFloat(x.valueOf());
		if (isNaN(f)) return null;
		return f;
	}
	return null;
}
function atom(x) {
	if (typeof x === \'symbol\' && x !== __Oak_Empty) return x;
	if (__is_oak_string(x)) return Symbol.for(x.valueOf());
	return Symbol.for(string(x));
}
function string(x) {
	x = __as_oak_string(x);
	function display(x) {
		if (__is_oak_string(x)) {
			return \'\\\'\' + x.valueOf().replace(\'\\\\\', \'\\\\\\\\\').replace(\'\\\'\', \'\\\\\\\'\') + \'\\\'\';
		}
		return string(x);
	}
	if (x === null) {
		return \'?\';
	} else if (typeof x === \'number\') {
		return x.toString();
	} else if (__is_oak_string(x)) {
		return x;
	} else if (typeof x === \'boolean\') {
		return x.toString();
	} else if (typeof x === \'function\') {
		return x.toString();
	} else if (typeof x === \'symbol\') {
		if (x === __Oak_Empty) return \'_\';
		return \':\' + Symbol.keyFor(x);
	} else if (Array.isArray(x)) {
		return \'[\' + x.map(display).join(\', \') + \']\';
	} else if (typeof x === \'object\') {
		const entries = [];
		for (const key of keys(x).sort()) {
			entries.push(`${key}: ${display(x[key])}`);
		}
		return \'{\' + entries.join(\', \') + \'}\';
	}
	throw new Error(\'string() called on unknown type \' + x.toString());
}
function codepoint(c) {
	c = __as_oak_string(c);
	return c.valueOf().charCodeAt(0);
}
function char(n) {
	return String.fromCharCode(n);
}
function type(x) {
	x = __as_oak_string(x);
	if (x === null) {
		return Symbol.for(\'null\');
	} else if (typeof x === \'number\') {
		// Many discrete APIs check for :int, so we consider all integer
		// numbers :int and fall back to :float. This is not an airtight
		// solution, but works well enough and the alternative (tagged number
		// values/types) have poor perf tradeoffs.
		if (Number.isInteger(x)) return Symbol.for(\'int\');
		return Symbol.for(\'float\');
	} else if (__is_oak_string(x)) {
		return Symbol.for(\'string\');
	} else if (typeof x === \'boolean\') {
		return Symbol.for(\'boolean\');
	} else if (typeof x === \'symbol\') {
		if (x === __Oak_Empty) return Symbol.for(\'empty\');
		return Symbol.for(\'atom\');
	} else if (typeof x === \'function\') {
		return Symbol.for(\'function\');
	} else if (Array.isArray(x)) {
		return Symbol.for(\'list\');
	} else if (typeof x === \'object\') {
		return Symbol.for(\'object\');
	}
	throw new Error(\'type() called on unknown type \' + x.toString());
}
function len(x) {
	x = __as_oak_string(x);
	if (__is_oak_string(x)) {
		return x.length;
	} else if (Array.isArray(x)) {
		return x.length;
	} else if (typeof x === \'object\' && x !== null) {
		return Object.getOwnPropertyNames(x).length;
	}
	throw new Error(\'len() takes a string or composite value, but got \' + string(x));
}
function keys(x) {
	if (Array.isArray(x)) {
		const k = [];
		for (let i = 0; i < x.length; i ++) k.push(i);
		return k;
	} else if (typeof x === \'object\' && x !== null) {
		return Object.getOwnPropertyNames(x);
	}
	throw new Error(\'keys() takes a composite value, but got \' + string(x).valueOf());
}

// OS interfaces
function args() {
	if (__Is_Oak_Node) return process.argv;
	return [];
}
function env() {
	if (__Is_Oak_Node) return process.env;
	return {};
}
function time() {
	return Date.now() / 1000;
}
function nanotime() {
	return int(Date.now() * 1000000);
}
function rand() {
	return Math.random();
}
function wait(duration, cb) {
	setTimeout(cb, duration * 1000);
	return null;
}
function exit(code) {
	if (__Is_Oak_Node) process.exit(code);
	return null;
}
function exec() {
	throw new Error(\'exec() not implemented\');
}

// I/O
function input() {
	throw new Error(\'input() not implemented\');
}
function print(s) {
	s = __as_oak_string(s);
	if (__Is_Oak_Node) {
		process.stdout.write(string(s).toString());
	} else {
		console.log(string(s).toString());
	}
	return s.length;
}
function ls() {
	throw new Error(\'ls() not implemented\');
}
function rm() {
	throw new Error(\'rm() not implemented\');
}
function mkdir() {
	throw new Error(\'mkdir() not implemented\');
}
function stat() {
	throw new Error(\'stat() not implemented\');
}
function open() {
	throw new Error(\'open() not implemented\');
}
function close() {
	throw new Error(\'close() not implemented\');
}
function read() {
	throw new Error(\'read() not implemented\');
}
function write() {
	throw new Error(\'write() not implemented\');
}
function listen() {
	throw new Error(\'listen() not implemented\');
}
function req() {
	throw new Error(\'req() not implemented\');
}

// math
function sin(n) {
	return Math.sin(n);
}
function cos(n) {
	return Math.cos(n);
}
function tan(n) {
	return Math.tan(n);
}
function asin(n) {
	return Math.asin(n);
}
function acos(n) {
	return Math.acos(n);
}
function atan(n) {
	return Math.atan(n);
}
function pow(b, n) {
	return Math.pow(b, n);
}
function log(b, n) {
	return Math.log(n) / Math.log(b);
}

// runtime
function ___runtime_lib() {
	throw new Error(\'___runtime_lib() not implemented\');
}
function ___runtime_lib__oak_qm() {
	throw new Error(\'___runtime_lib?() not implemented\');
}

// JavaScript interop
function jsNew(Constructor, ...args) {
	return new Constructor(...args);
}
'
